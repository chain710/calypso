#ifndef _APP_INTERFACE_H_
#define _APP_INTERFACE_H_
#include <netinet/in.h>
#ifdef __cplusplus
extern "C"
{
#endif
    // TODO: is it necessary to notify link close event to appthread?
    // if yes, we must ensure 
    // 1.same fd dispatched to same appthread, otherwise there might be timing issues
    enum msgpack_flag_t
    {
        mpf_closed_by_peer = 0x00000001,
        mpf_new_connection = 0x00000002,
        mpf_close_link = 0x00000004,    // worker->dispatch close link
    };

    enum transfer_type_t
    {
        tt_broadcast_group = -2,   // broadcast links in group
        tt_send_group = -1,    // random pick
    };

    struct msgpack_context_t
    {
        int magic_;     // magic number(0)
        int link_ctx_;  // transparent
        int link_fd_;   // >=0 fd
        unsigned int flag_; // see msgpack_flag_t
        short link_type_;   // see netlink_t linktype
        short extrabuf_len_;   // extrabuf generated by app_get_msgpack_size_func_t
        sockaddr_in remote_;    // remote addr
        sockaddr_in local_;     // local addr
    };

    struct app_init_option
    {
        int th_idx_;
        void* msg_queue_;
    };

    // init appthread
    typedef void* (*app_initialize_func_t)(app_init_option opt, const char* bootstrap_config);
    // destory appthread
    typedef void (*app_finalize_func_t)(void* app_inst);
    // handle tick
    typedef void (*app_handle_tick_func_t)(void* app_inst);
    /*
     *	return msgpack len in buf, 0=insufficient msgpack, >0 length of msgpack, <0 parse error, buf might be corrupted
     *  NOTE:app_get_msgpack_size_func_t is called directly by main thread, so no appinst ptr provided
     *  OUT: extra_buf, extrabuflen, extrabuf will be sent to appthread along with msgpack. structure:[ctx,extrabuf,msgpack]
     */
    typedef int (*app_get_msgpack_size_func_t)(const msgpack_context_t* ctx, const char*, size_t, char* extra_buf, size_t*);
    // handle one msgpack
    typedef int (*app_handle_msgpack_func_t)(void* app_inst, const msgpack_context_t* ctx, const char*, size_t);

    struct app_handler_t
    {
        app_initialize_func_t init_;
        app_finalize_func_t fina_;
        app_handle_tick_func_t handle_tick_;
        app_get_msgpack_size_func_t get_msgpack_size_;
        app_handle_msgpack_func_t handle_msgpack_;
    };

    //////////////////////////////////////////////////////////////////////////
    // app implementation
    //////////////////////////////////////////////////////////////////////////
    // return apphandler
    app_handler_t get_app_handler();
    // global init, initiate global vars here, read lock if necessary
    int app_global_init(const char* bootstrap_config);
    // global reload
    void app_global_reload();
    // global fina
    void app_global_fina();

    //////////////////////////////////////////////////////////////////////////
    // app callable
    //////////////////////////////////////////////////////////////////////////
    // send response msg by ctx
    int calypso_send_msgpack_by_ctx(void* queue, const msgpack_context_t* ctx, const char* data, size_t len);

    // pick one link in specific group randomly, and send data
    int calypso_send_msgpack_by_group(void* queue, int group, const char* data, size_t len);

    // broadcast to all links in group
    int calypso_broadcast_msgpack_by_group(void* queue, int group, const char* data, size_t len);

    // check if need reload in msgloop
    bool calypso_need_reload(time_t last);
#ifdef __cplusplus
}
#endif

#endif

